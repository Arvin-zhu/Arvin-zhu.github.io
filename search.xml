<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js正则表达式]]></title>
    <url>%2F2019%2F03%2F21%2Fjs%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文正则用处正则就是用来处理字符串的:主要有匹配和捕获两个功能 匹配 匹配字符串的格式是否符合既定的格式(正则的匹配) 捕获 把一个字符串中符合既定格式的内容获取到(正则的捕获) 用法介绍pattern 为RegExp实例，str为字符串 用法 说明 返回值 pattern.test(str) 判断字符串是否包含匹配结果 包含返回true，否则返回false pattern.exec(str) 根据pattern对字符串进行正则匹配 匹配成功返回匹配结果数组，匹配失败返回null str.match(str) 根据pattern对字符串进行正则匹配 匹配成功返回匹配结果数组，匹配失败返回null str.replace(pattern, replaceCallback或者str) 根据pattern进行正则匹配，对匹配结果进行替换 返回新的字符串 常用元字符 特殊意义元字符 1234567891011\d -&gt; 匹配一个0-9的数字,相当于[0-9]\D -&gt; 匹配一个除了0-9的任意字符,相当于[^0-9]\w -&gt; 匹配一个0-9、a-z、A-Z、_的数字或字符,相当于[0-9a-zA-Z_]\W -&gt; 匹配非单词字符，相当于[^0-9a-zA-Z_]\s -&gt; 匹配一个空白字符(空格、制表符...)，相当于[ \t\v\n\r\f]\S -&gt; 匹配一个非空白字符，相当于[^ \t\v\n\r\f]. -&gt; 匹配一个任意字符，换行符、回车符、行分隔符、段分隔符除外，相当于[^\n\r\u2028\u2029][abc] -&gt; 匹配a、b、c中任意一个字符[^abc] -&gt; 匹配除了a、b、c外任意一个字符[0-9] -&gt; 匹配0-9中的任意数字[^0-9] -&gt; 匹配除了0-9的任意字符 代表数量的元字符 123456+ -&gt; 表示一个或多个，相当于&#123;1,&#125;? -&gt; 表示0个或1个，相当于&#123;0,1&#125;* -&gt; 表示任意数量，相当于&#123;0,&#125;&#123;m&#125; -&gt; 表示m个，相当于&#123;m,m&#125;&#123;m,&#125; -&gt; 表示至少m个&#123;m,n&#125; -&gt; 表示数量在m和n之间 代表位置的元字符 123456^ -&gt; 匹配字符串开头，在多行中也匹配行开头$ -&gt; 匹配字符串末尾，在多场中也匹配行结尾\b -&gt; 匹配单词边界，具体表示\w和\W、\w和^、\w和$之间的位置\B -&gt; 匹配非单词边界，具体表示\w和\w、\W和\W、^和\W、\W和$之间的位置(?=p) -&gt; 匹配字符p前面的位置(?!p) -&gt; 匹配字符串p非前面的位置 正则字符匹配实例 横向模糊匹配 12345678910const regex = /hello/;console.log(regex.test(&apos;hahahahelloworld&apos;)); //true// 检查字符串中是否含有&apos;hello&apos;const regex = /he&#123;3,5&#125;llo/;console.log(regex.test(&apos;heeello&apos;)) //trueconsole.log(regex.test(&apos;heeeello&apos;)) //trueconsole.log(regex.test(&apos;heeeeello&apos;)) //trueconsole.log(regex.test(&apos;heeeeeello&apos;)) //false// 匹配e的数量3-5个 纵向模糊匹配 123456const regex = /a[123]b/;console.log(regex.test(&apos;a1b&apos;)); //trueconsole.log(regex.test(&apos;a2b&apos;)); //trueconsole.log(regex.test(&apos;a3b&apos;)); //trueconsole.log(regex.test(&apos;a4b&apos;)); //false// [123]表示字符可以是1、2、3中任意一个 贪婪匹配 顾名思义贪婪匹配就是尽可能匹配多的字符 1234const regex = /\d&#123;3,5&#125;/g;const string = &quot;123 1234 12345 123456&quot;;console.log(string.match(regex)); // =&gt; [&quot;123&quot;,&quot;1234&quot;,&quot;12345&quot;,&quot;12345&quot;] 惰性匹配 顾名思义贪婪匹配就是尽可能匹配少的字符,格式就是在量词后面加个问号，比如{m,n}? 1234const regex = /\d&#123;3,5&#125;?/g;const string = &quot;123 1234 12345 123456&quot;;console.log(string.match(regex)); // =&gt; [&quot;123&quot;,&quot;123&quot;,&quot;123&quot;,&quot;123&quot;,&quot;456&quot;] 多选分支 符号“|”，表示支持多个子匹配模式 123const reagex = /dog|cat/g;const str = &apos;dog is pet, cat is pet&apos;;console.log(str.match(reagex))// [&apos;dog&apos;,&apos;cat&apos;] 注意：如果用/dog|dogcat/去匹配”dogcat”时结果是[“dog”] 123const reagex = /dog|dogcat/g;const str = &apos;dogcat dogcat&apos;;console.log(str.match(reagex))// [&apos;dog&apos;,&apos;dog&apos;] 由此可见分支匹配是惰性的 位置匹配 ^和$匹配(开头位置和结尾位置匹配) 123const str = &apos;hello.[world]&apos;;const regex = /^|$/g;console.log(str.replace(regex, &apos;#&apos;)); // &quot;#hello.[world]#&quot; \b 单词边界匹配 123const str = &apos;hello.[world]&apos;;const regex = /\b/g;console.log(str.replace(regex, &apos;#&apos;)); // #hello#.[#world#] \B 非单词边界匹配 123const str = &apos;hello.[world]&apos;;const regex = /\B/g;console.log(str.replace(regex, &apos;#&apos;)); // h#e#l#l#o.#[w#o#r#l#d]# (?=o) o字符前面位置匹配 123const str = &apos;hello.[world]&apos;;const regex = /(?=o)/g;console.log(str.replace(regex, &apos;#&apos;)); // hell#o.[w#orld] (?!o) 除了o字符前面位置外所有位置匹配 123const str = &apos;hello.[world]&apos;;const regex = /(?!o)/g;console.log(str.replace(regex, &apos;#&apos;)); // #h#e#l#lo#.#[#wo#r#l#d#]# 括号 括号的作用：分组和引用 分组功能：将多个字符组成一个整体，对这个整体进行匹配 123const str = &quot;abab abbba ababab&quot;;const regex = /(ab)+/g;console.log(str.match(regex));// [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;] 使用括号将(ab)看成一个整体，对ab这个整体进行匹配，此外由结果可见”+”是贪婪匹配 12345const regex = /^i love (cat|dog|monkey)$/;console.log(regex.test(&apos;i love cat&apos;)); //trueconsole.log(regex.test(&apos;i love dog&apos;)); //trueconsole.log(regex.test(&apos;i love monkey&apos;)); //true console.log(regex.test(&apos;i love pig&apos;)); //false 引用功能：引用功能主要是提取匹配到的字符串，然后对其进行各种操作 提取数据 比如：提取日期中的年、月、日 12345678const str = &apos;2019-03-01&apos;;const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;console.log(str.match(regex));// [&quot;2019-03-01&quot;, &quot;2019&quot;, &quot;03&quot;, &quot;01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined]console.log(RegExp.$1); // 2019console.log(RegExp.$2); // 03console.log(RegExp.$3); // 01console.log(RegExp.$4); // 空 由此可见通过构造函数的全局属性$1-$9能获取匹配到的字符 数据操作比如：将”2019-03-01”替换成”01-03-2019”12345678const str = &apos;2019-03-01&apos;;const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;const result = str.replace(regex, &quot;$3-$2-$1&quot;);const result2 = str.replace(regex, (match, $1, $2, $3) =&gt; &#123; return $3 + &apos;-&apos; + $2 + &apos;-&apos; + $1 // match 返回匹配到的字符&quot;2019-03-01&quot;&#125;);console.log(result) // &quot;01-03-2019&quot;console.log(result2) // &quot;01-03-2019&quot; 反向引用比如写一个正则匹配：’2019-03-01’,’2019/03/01’,’2019.03.01’ 第一反应可能是： 123456const regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/; // 注意转义.和/;console.log(regex.test(&apos;2019-03-01&apos;)) // trueconsole.log(regex.test(&apos;2019/03/01&apos;)) // trueconsole.log(regex.test(&apos;2019.03.01&apos;)) //trueconsole.log(regex.test(&apos;2019/03-01&apos;)) // true 这种错误的格式也匹配上了 由最后的结果可以知道这个正则并不完美，现在要解决的问题是如何保证日期分割符前后一致，此时可以使用反向引用 123456const regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/; // 注意转义.和/,使用\1来引用前一个分组;console.log(regex.test(&apos;2019-03-01&apos;)) // trueconsole.log(regex.test(&apos;2019/03/01&apos;)) // trueconsole.log(regex.test(&apos;2019.03.01&apos;)) //trueconsole.log(regex.test(&apos;2019/03-01&apos;)) // false 反向引用括号嵌套 括号嵌套以左括号为准 1234567const regex = /^((\w)(\w(\w)))\1\2\3\4$/;const str = &quot;abcabcabcc&quot;;console.log(regex.test(str)); // trueconsole.log(RegExp.$1); // abcconsole.log(RegExp.$2); // aconsole.log(RegExp.$3); // bcconsole.log(RegExp.$4); // c 分析： 第一个”(“括号的分组内容是abc; 第二个”(“括号的分组内容是a; 第三个”(“括号的分组内容是bc; 第四个”(“括号的分组内容是c; 非捕获分组 由前面的例子可以看出括号可以捕获匹配到的字符，然后用RegExp的api来访问捕获字符或者通过反向引用来访问捕获的字符，那么如果不想要捕获，只想要括号最原始的功能这时就可以使用非捕获分组(?:) 12345678const str = &apos;2019-03-01&apos;;const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; // 捕获const regex2 = /(?:\d&#123;4&#125;)-(?:\d&#123;2&#125;)-(?:\d&#123;2&#125;)/; // 非捕获console.log(str.match(regex));// [&quot;2019-03-01&quot;, &quot;2019&quot;, &quot;03&quot;, &quot;01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined]console.log(str.match(regex2)); // [&quot;2019-03-01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined] 由上面实例可以看出使用非捕获分组(?:)就没有捕获到匹配的字符]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-native-pushy实现Android和IOS热更新]]></title>
    <url>%2F2019%2F02%2F21%2Freact-native-pushy%E5%AE%9E%E7%8E%B0Android%E5%92%8CIOS%E7%83%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[热更新主要是用来更新JS和图片，就是在不重新安装应用的情况下，完成JS和图片的更新，如果是要更新原生层代码那么还是要重新安装应用的react-native-pushy：githubupdate服务：地址配置和集成参考文章：官方文档：地址 CSDN 热更新 Android: 地址 CSDN 热更新 IOS: 地址 简书：地址 总结：准备工作： 如果RN版本小于0.45，需要先安装Android NDK(版本推荐r10e)，并设置环境变量ANDROID_NDK_HOME指向你的根目录 如果RN版本是0.46以上那么不需要安装NDK 安装：123npm i -g react-native-update-cli //同一台电脑只需要执行一次npm i react-native-update@具体版本请参考官网react-native link react-native-update 手动link如果react-native link react-native-update执行成功，则不需要手动link ios手动link 在XCode中的Project Navigator里,右键点击Libraries -&gt; Add Files to [你的工程名] 进入项目node_modules文件夹找到react-native-update里ios文件夹下的RCTHotUpdate.xcodeproj文件并选中 在项目的 Build Phases 找到 Link Binary With Libraries 点击下方的 + 加号依次添加 RCTHotUpdate.a 和 libz.tbd 还有 libbz2.1.0.tbd 继续在Build Settings里搜索Header Search Path，添加$(SRCROOT)/../node_modules/react-native-update/ios android手动link 在android/settings.gradle中添加如下代码： 12include &apos;:react-native-update&apos;project(&apos;:react-native-update&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-update/android&apos;) 在android/app/build.gradle dependencies部分增加如下代码： 1compile project(&apos;:react-native-update&apos;) 打开android/app/src/main/java/[...]/MainApplication.java,在文件开头增加： 1import cn.reactnative.modules.update.UpdatePackage 在getPackages() 方法中增加 new UpdatePackage()(注意上一行可能要增加一个逗号) 配置Bundle UrlIOS打开AppDelegate.m文件增加如下代码：12345#if DEBUG // 原来的jsCodeLocation#else jsCodeLocation=[RCTHotUpdate bundleURL];#endif Android在你的android/app/src/main/java/[...]/MainApplication.java中增加如下代码：1234567891011121314// ... 其它代码// 请注意不要少了这句importimport cn.reactnative.modules.update.UpdateContext;public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected String getJSBundleFile() &#123; return UpdateContext.getBundleUrl(MainApplication.this); &#125; // ... 其它代码 &#125;&#125; ios的ATS例外配置从iOS9开始，苹果要求以白名单的形式在Info.plist中列出外部的非https接口，以督促开发者部署https协议。12345678910111213&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;reactnative.cn&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; 在Update服务中创建应用 先注册账号http://update.reactnative.cn 在项目根目录下开启终端，然后执行pushy login命令，输入邮箱和密码，回车登录 登录之后项目根目录下会有.update文件(注意不要把这个文件上传到git或者svn) 登录之后可以创建应用，创建方法如下：12$ pushy createApp --platform ios //创建ios应用$ pushy createApp --platform android //创建android应用 常用操作命令：123456$ pushy login //登录$ pushy createApp --platform [ios/android] //创建应用$ pushy selectApp --platform [ios/android] //选择应用$ pushy bundle --platform [ios/android] //发布热更新版本$ pushy uploadIpa [ipa地址] //上传ios应用，用作版本对比$ pushy uploadApk [apk地址] //上传android应用，用作版本对比 配置应用层更新时下载应用的地址： 登录 http://update.reactnative.cn 进入你的应用 点击顶部导航栏的【设置】，配置下载地址 JS端集成代码1. 获取appKey检查更新时必须提供你的appKey，这个值保存在update.json中，并且根据平台不同而不同。 123import &#123; Platform &#125; from &apos;reactNative&apos;;import _updateConfig from &apos;./update.json&apos;;const &#123;appKey&#125; = _updateConfig[Platform.OS]; 2. 检查更新12345678910111213141516checkUpdate = () =&gt; &#123; checkUpdate(appKey).then(info =&gt; &#123; if (info.expired) &#123; //检测到应用层更新 // info.downloadUrl就是在网站中配置的下载地址 Alert.alert(&apos;提示&apos;, &apos;您的应用版本已更新,请前往应用商店下载新的版本&apos;, [ &#123;text: &apos;确定&apos;, onPress: () =&gt; &#123;info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)&#125;&#125;, ], &#123; onDismiss: () =&gt; &#123; console.log(&apos;取消&apos;) &#125;&#125;); &#125; else if (info.upToDate) &#123; // 检测到版本已经时最新 &#125; else &#123; // 检测到热更新 &#125; &#125;).catch(err =&gt; &#123; console.log(&apos;updatefailed===&apos;, err); &#125;);&#125; 3. 下载更新、切换版本12345678910111213doUpdate = (info) =&gt; &#123; downloadUpdate(info).then(hash =&gt; &#123; if (hash) &#123; Alert.alert(&apos;提示&apos;, &apos;下载完毕,是否重启应用?&apos;, [ &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;switchVersion(hash);&#125;&#125;, &#123;text: &apos;否&apos;,&#125;, &#123;text: &apos;下次启动时&apos;, onPress: ()=&gt;&#123;switchVersionLater(hash);&#125;&#125;, ]); &#125;; &#125;).catch(err =&gt; &#123; console.log(&apos;提示&apos;, &apos;更新失败.&apos;); &#125;);&#125; 4. 关于首次启动、回滚在每次更新完毕后的首次启动时，isFirstTime常量会为true。 你必须在应用退出前合适的任何时机，调用markSuccess，否则应用下一次启动的时候将会进行回滚操作。 这一机制称作“反触发”，这样当你应用启动初期即遭遇问题的时候，也能在下一次启动时恢复运作。 你可以通过isFirstTime来获知这是当前版本的首次启动，也可以通过isRolledBack来获知应用刚刚经历了一次回滚操作。 你可以在此时给予用户合理的提示。 5.核心代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import &#123; ... Platform, ...&#125; from &apos;react-native&apos;;import &#123; isFirstTime, isRolledBack, packageVersion, currentVersion, checkUpdate, downloadUpdate, switchVersion, switchVersionLater, markSuccess,&#125; from &apos;react-native-update&apos;;...import _updateConfig from &apos;./update.json&apos;;const &#123;appKey&#125; = _updateConfig[Platform.OS];......componentWillMount()&#123; if (isFirstTime) &#123; Alert.alert(&apos;提示&apos;, &apos;这是当前版本第一次启动,是否要模拟启动失败?失败将回滚到上一版本&apos;, [ &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;throw new Error(&apos;模拟启动失败,请重启应用&apos;)&#125;&#125;, &#123;text: &apos;否&apos;, onPress: ()=&gt;&#123;markSuccess()&#125;&#125;, ]); &#125; else if (isRolledBack) &#123; Alert.alert(&apos;提示&apos;, &apos;刚刚更新失败了,版本被回滚.&apos;); &#125; &#125; doUpdate = info =&gt; &#123; downloadUpdate(info).then(hash =&gt; &#123; Alert.alert(&apos;提示&apos;, &apos;下载完毕,是否重启应用?&apos;, [ &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;switchVersion(hash);&#125;&#125;, &#123;text: &apos;否&apos;,&#125;, &#123;text: &apos;下次启动时&apos;, onPress: ()=&gt;&#123;switchVersionLater(hash);&#125;&#125;, ]); &#125;).catch(err =&gt; &#123; Alert.alert(&apos;提示&apos;, &apos;更新失败.&apos;); &#125;); &#125;; checkUpdate = () =&gt; &#123; checkUpdate(appKey).then(info =&gt; &#123; if (info.expired) &#123; Alert.alert(&apos;提示&apos;, &apos;您的应用版本已更新,请前往应用商店下载新的版本&apos;, [ &#123;text: &apos;确定&apos;, onPress: ()=&gt;&#123;info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)&#125;&#125;, ]); &#125; else if (info.upToDate) &#123; Alert.alert(&apos;提示&apos;, &apos;您的应用版本已是最新.&apos;); &#125; else &#123; Alert.alert(&apos;提示&apos;, &apos;检查到新的版本&apos;+info.name+&apos;,是否下载?\n&apos;+ info.description, [ &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;this.doUpdate(info)&#125;&#125;, &#123;text: &apos;否&apos;,&#125;, ]); &#125; &#125;).catch(err =&gt; &#123; Alert.alert(&apos;提示&apos;, &apos;更新失败.&apos;); &#125;); &#125;; ... ... Android 原生层代码更新，自动下载、安装apk实现：准备工作： 安装第三方依赖：react-native-fs、react-native-install-apk 开放android读写文件权限 打开 android/app/src/main/AndroidManifest.xml添加12&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import &#123; ...... NativeModules &#125; from &apos;react-native&apos;; import RNFS from &apos;react-native-fs&apos;; ...... ...... checkUpdate(appKey).then(info =&gt; &#123; //热更新检查 if (info.expired) &#123; //检查原生层代码更新 if (info.downloadUrl) &#123; // 如果在update服务中配置了应用下载地址 RNFS.mkdir(&quot;/sdcard/yymedic&quot;).then(() =&gt; &#123; const filePath = RNFS.ExternalStorageDirectoryPath + &quot;/yymedic/yy-nurse.apk&quot;; const download = RNFS.downloadFile(&#123; fromUrl: info.downloadUrl, toFile: filePath, progress: res =&gt; &#123; // 下载进度 that.setState(&#123; downloadProgress: ((res.bytesWritten / res.contentLength) * 100).toFixed(2) &#125;); &#125;, progressDivider: 1 // 下载进度回调的步频，比如10，那么进度在0、10、20....处触发回调 &#125;); download.promise.then(result =&gt; &#123; if (result.statusCode == 200) &#123; that.setState(&#123; downloadProgress: 0, updating: false &#125;); NativeModules.InstallApk.install(filePath); // 下载成功之后安装apk &#125; else &#123; Toast.info(&apos;更新失败&apos;, 1); that.setState(&#123; downloadProgress: 0, updating: false &#125;); &#125; &#125;).catch(err =&gt; &#123; Toast.info(&apos;更新失败&apos;, 1); that.setState(&#123; downloadProgress: 0, updating: false &#125;); &#125;); &#125;).catch(err =&gt; &#123; Toast.info(&apos;更新失败&apos;, 1); that.setState(&#123; updating: false &#125;); console.log(&apos;提示&apos;, &apos;更新失败.&apos;, err); &#125;); &#125; else &#123; that.setState(&#123; updating: false &#125;); &#125; &#125; else if (info.upToDate) &#123; // 如果是最新的，则执行其他操作 &#125; else &#123; // 热更新代码逻辑 &#125;&#125;).catch(err =&gt; &#123; Toast.info(&apos;更新失败&apos;, 1); console.log(&apos;提示&apos;, &apos;更新失败.&apos;, err);&#125;);............]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-native开发碰到的问题及插件整理]]></title>
    <url>%2F2019%2F02%2F19%2Freact-native%E5%BC%80%E5%8F%91%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. uncompiled PNG file描述：该问题出现在打包成release apk的时候12/Users/almouro/bam/uefa/TestGradle3/android/app/build/intermediates/res/merged/release/drawable-mdpi/image.png: error: uncompiled PNG file passed as argument. Must be compiled first into .flat file..error: failed parsing overlays. 解决方法：打开 android/gradle.properties 文件添加 android.enableAapt2=false 查看: github issues uncompiled PNG file 2. react-native modal 组件描述： 在使用react-native modal 组件的时候发现模态框并没有覆盖到手机状态栏 解决方法：react-native-modal-translucent 3. react-native 键盘弹出导致绝对定位元素上浮描述：当软键盘通过textInput组件唤起的时候，绝对定位元素上浮 解决方法：打开AndroidManifest.xml文件修改activity 中的 android:windowSoftinputMode=&quot;stateAlwaysHidden|adjustpan&quot; 参考连接：原文 windowSoftinputMode介绍：Developers 4. react-native 软键盘遮住textInput描述：当页面有多个 textInput 输入框，底部输入框唤起软键盘时会被遮住 解决方法：react-native-keyboard-aware-scroll-view 使用方法：12345678910111213import &#123; KeyboardAwareScrollView &#125; from &apos;react-native-keyboard-aware-scroll-view&apos;.........&lt;KeyboardAwareScrollView&gt; &lt;View&gt; &lt;TextInput /&gt; &lt;TextInput /&gt; &lt;TextInput /&gt; &lt;/View&gt;&lt;/KeyboardAwareScrollView&gt;...... 5. react-native 蓝牙通信描述：蓝牙分两种通信模式(BEL蓝牙 和 经典蓝牙)，对于BLE蓝牙推荐使用react-native-ble-manager 组件，对于经典蓝牙推荐使用react-native-bluetooth-serial 解决方法： BLE蓝牙：react-native-ble-manager 经典蓝牙: react-native-bluetooth-serial]]></content>
  </entry>
  <entry>
    <title><![CDATA[setMonth导致获取月份错误]]></title>
    <url>%2F2019%2F02%2F12%2FsetMonth%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题重现 1234 // 比如今天是 2017-03-31 号，理论上后推一个月应该是4月 let now = new Date(new Date(&quot;2017-03-31&quot;).setMonth(new Date(&quot;2017-03-31&quot;).getMonth() + 1))console.log(&apos;now :&apos;, now.getMonth())// 结果是：now : 2017/5/1 上午8:00:00 实际的结果和预想的结果不一致！！ MDN解释： If you do not specify the dayValue parameter, the value returned from the getDate() method is used.If a parameter you specify is outside of the expected range, setMonth() attempts to update the date information in the Date object accordingly. For example, if you use 15 for monthValue, the year will be incremented by 1, and 3 will be used for month.The current day of month will have an impact on the behaviour of this method. Conceptually it will add the number of days given by the current day of the month to the 1st day of the new month specified as the parameter, to return the new date. For example, if the current value is 31st August 2016, calling setMonth with a value of 1 will return 2nd March 2016. This is because in 2016 February had 29 days. 查看MDN解释 简单来说就是：对当前的日期调用setMonth操作时，如果当前月份的天数大于新的月份天数，那么日期会依次向后推。1234567let now = new Date(new Date(&quot;2017-03-31&quot;).setMonth(new Date(&quot;2017-03-31&quot;).getMonth() + 1))console.log(&apos;now :&apos;, now.toLocaleString())// now : 2017/5/1 上午8:00:00// 2017-03-31 该月份有31天，当调用getMonth() + 1时// 理论上会加上当前月份的最大值31// 这时计算之后的日期是2017-04-31// 但是4月只有30天，所以后推一天变成2017-05-01,所以月份变成了5月 解决方法 setMonth之前先setDate(1) 12345678function getNextMonth(date) &#123; const now = new Date(date); now.setDate(1); now.setMonth(now.getMonth() + 1); return now.getMonth() + 1;&#125;console.log(getNextMonth(&quot;2017-03-31&quot;))// 4 结果正确]]></content>
  </entry>
</search>
