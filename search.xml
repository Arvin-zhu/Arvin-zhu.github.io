<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react-native-pushy实现Android和IOS热更新]]></title>
    <url>%2F2019%2F02%2F21%2Freact-native-pushy%E5%AE%9E%E7%8E%B0Android%E5%92%8CIOS%E7%83%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[热更新主要是用来更新JS和图片，就是在不重新安装应用的情况下，完成JS和图片的更新，如果是要更新原生层代码那么还是要重新安装应用的react-native-pushy：githubupdate服务：地址配置和集成参考文章：官方文档：地址 CSDN 热更新 Android: 地址 CSDN 热更新 IOS: 地址 简书：地址 总结：准备工作： 如果RN版本小于0.45，需要先安装Android NDK(版本推荐r10e)，并设置环境变量ANDROID_NDK_HOME指向你的根目录 如果RN版本是0.46以上那么不需要安装NDK 安装：123npm i -g react-native-update-cli //同一台电脑只需要执行一次npm i react-native-update@具体版本请参考官网react-native link react-native-update 手动link如果react-native link react-native-update执行成功，则不需要手动link ios手动link 在XCode中的Project Navigator里,右键点击Libraries -&gt; Add Files to [你的工程名] 进入项目node_modules文件夹找到react-native-update里ios文件夹下的RCTHotUpdate.xcodeproj文件并选中 在项目的 Build Phases 找到 Link Binary With Libraries 点击下方的 + 加号依次添加 RCTHotUpdate.a 和 libz.tbd 还有 libbz2.1.0.tbd 继续在Build Settings里搜索Header Search Path，添加$(SRCROOT)/../node_modules/react-native-update/ios android手动link 在android/settings.gradle中添加如下代码： 12include &apos;:react-native-update&apos;project(&apos;:react-native-update&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-update/android&apos;) 在android/app/build.gradle dependencies部分增加如下代码： 1compile project(&apos;:react-native-update&apos;) 打开android/app/src/main/java/[...]/MainApplication.java,在文件开头增加： 1import cn.reactnative.modules.update.UpdatePackage 在getPackages() 方法中增加 new UpdatePackage()(注意上一行可能要增加一个逗号) 配置Bundle UrlIOS打开AppDelegate.m文件增加如下代码：12345#if DEBUG // 原来的jsCodeLocation#else jsCodeLocation=[RCTHotUpdate bundleURL];#endif Android在你的android/app/src/main/java/[...]/MainApplication.java中增加如下代码：1234567891011121314// ... 其它代码// 请注意不要少了这句importimport cn.reactnative.modules.update.UpdateContext;public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected String getJSBundleFile() &#123; return UpdateContext.getBundleUrl(MainApplication.this); &#125; // ... 其它代码 &#125;&#125; ios的ATS例外配置从iOS9开始，苹果要求以白名单的形式在Info.plist中列出外部的非https接口，以督促开发者部署https协议。12345678910111213&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;reactnative.cn&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; 在Update服务中创建应用 先注册账号http://update.reactnative.cn 在项目根目录下开启终端，然后执行pushy login命令，输入邮箱和密码，回车登录 登录之后项目根目录下会有.update文件(注意不要把这个文件上传到git或者svn) 登录之后可以创建应用，创建方法如下：12$ pushy createApp --platform ios //创建ios应用$ pushy createApp --platform android //创建android应用 常用操作命令：123456$ pushy login //登录$ pushy createApp --platform [ios/android] //创建应用$ pushy selectApp --platform [ios/android] //选择应用$ pushy bundle --platform [ios/android] //发布热更新版本$ pushy uploadIpa [ipa地址] //上传ios应用，用作版本对比$ pushy uploadApk [apk地址] //上传android应用，用作版本对比 配置应用层更新时下载应用的地址： 登录 http://update.reactnative.cn 进入你的应用 点击顶部导航栏的【设置】，配置下载地址 JS端集成代码1. 获取appKey检查更新时必须提供你的appKey，这个值保存在update.json中，并且根据平台不同而不同。 123import &#123; Platform &#125; from &apos;reactNative&apos;;import _updateConfig from &apos;./update.json&apos;;const &#123;appKey&#125; = _updateConfig[Platform.OS]; 2. 检查更新12345678910111213141516checkUpdate = () =&gt; &#123; checkUpdate(appKey).then(info =&gt; &#123; if (info.expired) &#123; //检测到应用层更新 // info.downloadUrl就是在网站中配置的下载地址 Alert.alert(&apos;提示&apos;, &apos;您的应用版本已更新,请前往应用商店下载新的版本&apos;, [ &#123;text: &apos;确定&apos;, onPress: () =&gt; &#123;info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)&#125;&#125;, ], &#123; onDismiss: () =&gt; &#123; console.log(&apos;取消&apos;) &#125;&#125;); &#125; else if (info.upToDate) &#123; // 检测到版本已经时最新 &#125; else &#123; // 检测到热更新 &#125; &#125;).catch(err =&gt; &#123; console.log(&apos;updatefailed===&apos;, err); &#125;);&#125; 3. 下载更新、切换版本12345678910111213doUpdate = (info) =&gt; &#123; downloadUpdate(info).then(hash =&gt; &#123; if (hash) &#123; Alert.alert(&apos;提示&apos;, &apos;下载完毕,是否重启应用?&apos;, [ &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;switchVersion(hash);&#125;&#125;, &#123;text: &apos;否&apos;,&#125;, &#123;text: &apos;下次启动时&apos;, onPress: ()=&gt;&#123;switchVersionLater(hash);&#125;&#125;, ]); &#125;; &#125;).catch(err =&gt; &#123; console.log(&apos;提示&apos;, &apos;更新失败.&apos;); &#125;);&#125; 4. 关于首次启动、回滚在每次更新完毕后的首次启动时，isFirstTime常量会为true。 你必须在应用退出前合适的任何时机，调用markSuccess，否则应用下一次启动的时候将会进行回滚操作。 这一机制称作“反触发”，这样当你应用启动初期即遭遇问题的时候，也能在下一次启动时恢复运作。 你可以通过isFirstTime来获知这是当前版本的首次启动，也可以通过isRolledBack来获知应用刚刚经历了一次回滚操作。 你可以在此时给予用户合理的提示。 5.核心代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import &#123; ... Platform, ...&#125; from &apos;react-native&apos;;import &#123; isFirstTime, isRolledBack, packageVersion, currentVersion, checkUpdate, downloadUpdate, switchVersion, switchVersionLater, markSuccess,&#125; from &apos;react-native-update&apos;;...import _updateConfig from &apos;./update.json&apos;;const &#123;appKey&#125; = _updateConfig[Platform.OS];......componentWillMount()&#123; if (isFirstTime) &#123; Alert.alert(&apos;提示&apos;, &apos;这是当前版本第一次启动,是否要模拟启动失败?失败将回滚到上一版本&apos;, [ &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;throw new Error(&apos;模拟启动失败,请重启应用&apos;)&#125;&#125;, &#123;text: &apos;否&apos;, onPress: ()=&gt;&#123;markSuccess()&#125;&#125;, ]); &#125; else if (isRolledBack) &#123; Alert.alert(&apos;提示&apos;, &apos;刚刚更新失败了,版本被回滚.&apos;); &#125; &#125; doUpdate = info =&gt; &#123; downloadUpdate(info).then(hash =&gt; &#123; Alert.alert(&apos;提示&apos;, &apos;下载完毕,是否重启应用?&apos;, [ &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;switchVersion(hash);&#125;&#125;, &#123;text: &apos;否&apos;,&#125;, &#123;text: &apos;下次启动时&apos;, onPress: ()=&gt;&#123;switchVersionLater(hash);&#125;&#125;, ]); &#125;).catch(err =&gt; &#123; Alert.alert(&apos;提示&apos;, &apos;更新失败.&apos;); &#125;); &#125;; checkUpdate = () =&gt; &#123; checkUpdate(appKey).then(info =&gt; &#123; if (info.expired) &#123; Alert.alert(&apos;提示&apos;, &apos;您的应用版本已更新,请前往应用商店下载新的版本&apos;, [ &#123;text: &apos;确定&apos;, onPress: ()=&gt;&#123;info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)&#125;&#125;, ]); &#125; else if (info.upToDate) &#123; Alert.alert(&apos;提示&apos;, &apos;您的应用版本已是最新.&apos;); &#125; else &#123; Alert.alert(&apos;提示&apos;, &apos;检查到新的版本&apos;+info.name+&apos;,是否下载?\n&apos;+ info.description, [ &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;this.doUpdate(info)&#125;&#125;, &#123;text: &apos;否&apos;,&#125;, ]); &#125; &#125;).catch(err =&gt; &#123; Alert.alert(&apos;提示&apos;, &apos;更新失败.&apos;); &#125;); &#125;; ... ... Android 原生层代码更新，自动下载、安装apk实现：准备工作： 安装第三方依赖：react-native-fs、react-native-install-apk 开放android读写文件权限 打开 android/app/src/main/AndroidManifest.xml添加12&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import &#123; ...... NativeModules &#125; from &apos;react-native&apos;; import RNFS from &apos;react-native-fs&apos;; ...... ...... checkUpdate(appKey).then(info =&gt; &#123; //热更新检查 if (info.expired) &#123; //检查原生层代码更新 if (info.downloadUrl) &#123; // 如果在update服务中配置了应用下载地址 RNFS.mkdir(&quot;/sdcard/yymedic&quot;).then(() =&gt; &#123; const filePath = RNFS.ExternalStorageDirectoryPath + &quot;/yymedic/yy-nurse.apk&quot;; const download = RNFS.downloadFile(&#123; fromUrl: info.downloadUrl, toFile: filePath, progress: res =&gt; &#123; // 下载进度 that.setState(&#123; downloadProgress: ((res.bytesWritten / res.contentLength) * 100).toFixed(2) &#125;); &#125;, progressDivider: 1 // 下载进度回调的步频，比如10，那么进度在0、10、20....处触发回调 &#125;); download.promise.then(result =&gt; &#123; if (result.statusCode == 200) &#123; that.setState(&#123; downloadProgress: 0, updating: false &#125;); NativeModules.InstallApk.install(filePath); // 下载成功之后安装apk &#125; else &#123; Toast.info(&apos;更新失败&apos;, 1); that.setState(&#123; downloadProgress: 0, updating: false &#125;); &#125; &#125;).catch(err =&gt; &#123; Toast.info(&apos;更新失败&apos;, 1); that.setState(&#123; downloadProgress: 0, updating: false &#125;); &#125;); &#125;).catch(err =&gt; &#123; Toast.info(&apos;更新失败&apos;, 1); that.setState(&#123; updating: false &#125;); console.log(&apos;提示&apos;, &apos;更新失败.&apos;, err); &#125;); &#125; else &#123; that.setState(&#123; updating: false &#125;); &#125; &#125; else if (info.upToDate) &#123; // 如果是最新的，则执行其他操作 &#125; else &#123; // 热更新代码逻辑 &#125;&#125;).catch(err =&gt; &#123; Toast.info(&apos;更新失败&apos;, 1); console.log(&apos;提示&apos;, &apos;更新失败.&apos;, err);&#125;);............]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-native开发碰到的问题及插件整理]]></title>
    <url>%2F2019%2F02%2F19%2Freact-native%E5%BC%80%E5%8F%91%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. uncompiled PNG file描述：该问题出现在打包成release apk的时候12/Users/almouro/bam/uefa/TestGradle3/android/app/build/intermediates/res/merged/release/drawable-mdpi/image.png: error: uncompiled PNG file passed as argument. Must be compiled first into .flat file..error: failed parsing overlays. 解决方法：打开 android/gradle.properties 文件添加 android.enableAapt2=false 查看: github issues uncompiled PNG file 2. react-native modal 组件描述： 在使用react-native modal 组件的时候发现模态框并没有覆盖到手机状态栏 解决方法：react-native-modal-translucent 3. react-native 键盘弹出导致绝对定位元素上浮描述：当软键盘通过textInput组件唤起的时候，绝对定位元素上浮 解决方法：打开AndroidManifest.xml文件修改activity 中的 android:windowSoftinputMode=&quot;stateAlwaysHidden|adjustpan&quot; 参考连接：原文 windowSoftinputMode介绍：Developers 4. react-native 软键盘遮住textInput描述：当页面有多个 textInput 输入框，底部输入框唤起软键盘时会被遮住 解决方法：react-native-keyboard-aware-scroll-view 使用方法：12345678910111213import &#123; KeyboardAwareScrollView &#125; from &apos;react-native-keyboard-aware-scroll-view&apos;.........&lt;KeyboardAwareScrollView&gt; &lt;View&gt; &lt;TextInput /&gt; &lt;TextInput /&gt; &lt;TextInput /&gt; &lt;/View&gt;&lt;/KeyboardAwareScrollView&gt;...... 5. react-native 蓝牙通信描述：蓝牙分两种通信模式(BEL蓝牙 和 经典蓝牙)，对于BLE蓝牙推荐使用react-native-ble-manager 组件，对于经典蓝牙推荐使用react-native-bluetooth-serial 解决方法： BLE蓝牙：react-native-ble-manager 经典蓝牙: react-native-bluetooth-serial]]></content>
  </entry>
  <entry>
    <title><![CDATA[setMonth导致获取月份错误]]></title>
    <url>%2F2019%2F02%2F12%2FsetMonth%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题重现 1234 // 比如今天是 2017-03-31 号，理论上后推一个月应该是4月 let now = new Date(new Date(&quot;2017-03-31&quot;).setMonth(new Date(&quot;2017-03-31&quot;).getMonth() + 1))console.log(&apos;now :&apos;, now.getMonth())// 结果是：now : 2017/5/1 上午8:00:00 实际的结果和预想的结果不一致！！ MDN解释： If you do not specify the dayValue parameter, the value returned from the getDate() method is used.If a parameter you specify is outside of the expected range, setMonth() attempts to update the date information in the Date object accordingly. For example, if you use 15 for monthValue, the year will be incremented by 1, and 3 will be used for month.The current day of month will have an impact on the behaviour of this method. Conceptually it will add the number of days given by the current day of the month to the 1st day of the new month specified as the parameter, to return the new date. For example, if the current value is 31st August 2016, calling setMonth with a value of 1 will return 2nd March 2016. This is because in 2016 February had 29 days. 查看MDN解释 简单来说就是：对当前的日期调用setMonth操作时，如果当前月份的天数大于新的月份天数，那么日期会依次向后推。1234567let now = new Date(new Date(&quot;2017-03-31&quot;).setMonth(new Date(&quot;2017-03-31&quot;).getMonth() + 1))console.log(&apos;now :&apos;, now.toLocaleString())// now : 2017/5/1 上午8:00:00// 2017-03-31 该月份有31天，当调用getMonth() + 1时// 理论上会加上当前月份的最大值31// 这时计算之后的日期是2017-04-31// 但是4月只有30天，所以后推一天变成2017-05-01,所以月份变成了5月 解决方法 setMonth之前先setDate(1) 12345678function getNextMonth(date) &#123; const now = new Date(date); now.setDate(1); now.setMonth(now.getMonth() + 1); return now.getMonth() + 1;&#125;console.log(getNextMonth(&quot;2017-03-31&quot;))// 4 结果正确]]></content>
  </entry>
</search>
