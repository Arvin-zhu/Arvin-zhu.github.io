<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    js正则表达式 |
    
    一只程序猪</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="blog-js正则表达式" class="article article-type-blog" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      js正则表达式
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/03/21/js正则表达式/" class="article-date">
  <time datetime="2019-03-21T14:32:46.000Z" itemprop="datePublished">2019-03-21</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h4 id="此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文"><a href="#此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文" class="headerlink" title="此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文"></a>此文章是看完<a href="https://juejin.im/post/5965943ff265da6c30653879#heading-26" target="_blank" rel="noopener">老姚-JS正则表达式完整教程</a>之后整理的，原文写的通熟易懂，建议大家阅读原文</h4><h4 id="正则用处"><a href="#正则用处" class="headerlink" title="正则用处"></a>正则用处</h4><p>正则就是用来处理字符串的:主要有<strong>匹配</strong>和<strong>捕获</strong>两个功能</p>
<ul>
<li><p>匹配</p>
<p>  匹配字符串的格式是否符合既定的格式(正则的匹配)</p>
</li>
<li><p>捕获</p>
<p>  把一个字符串中符合既定格式的内容获取到(正则的捕获)</p>
</li>
</ul>
<h4 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h4><p>pattern 为RegExp实例，str为字符串</p>
 <!-- <img src="/images/table.png" width="100%" /> -->
<table>
<thead>
<tr>
<th style="text-align:center">用法</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pattern.test(str)</td>
<td style="text-align:center">判断字符串是否包含匹配结果</td>
<td style="text-align:center">包含返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:center">pattern.exec(str)</td>
<td style="text-align:center">根据pattern对字符串进行正则匹配</td>
<td style="text-align:center">匹配成功返回匹配结果数组，匹配失败返回null</td>
</tr>
<tr>
<td style="text-align:center">str.match(str)</td>
<td style="text-align:center">根据pattern对字符串进行正则匹配</td>
<td style="text-align:center">匹配成功返回匹配结果数组，匹配失败返回null</td>
</tr>
<tr>
<td style="text-align:center">str.replace(pattern, replaceCallback或者str)</td>
<td style="text-align:center">根据pattern进行正则匹配，对匹配结果进行替换</td>
<td style="text-align:center">返回新的字符串</td>
</tr>
</tbody>
</table>
<h4 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h4><ul>
<li><p>特殊意义元字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\d -&gt; 匹配一个0-9的数字,相当于[0-9]</span><br><span class="line">\D -&gt; 匹配一个除了0-9的任意字符,相当于[^0-9]</span><br><span class="line">\w -&gt; 匹配一个0-9、a-z、A-Z、_的数字或字符,相当于[0-9a-zA-Z_]</span><br><span class="line">\W -&gt; 匹配非单词字符，相当于[^0-9a-zA-Z_]</span><br><span class="line">\s -&gt; 匹配一个空白字符(空格、制表符...)，相当于[ \t\v\n\r\f]</span><br><span class="line">\S -&gt; 匹配一个非空白字符，相当于[^ \t\v\n\r\f]</span><br><span class="line">. -&gt; 匹配一个任意字符，换行符、回车符、行分隔符、段分隔符除外，相当于[^\n\r\u2028\u2029]</span><br><span class="line">[abc] -&gt; 匹配a、b、c中任意一个字符</span><br><span class="line">[^abc] -&gt; 匹配除了a、b、c外任意一个字符</span><br><span class="line">[0-9] -&gt; 匹配0-9中的任意数字</span><br><span class="line">[^0-9] -&gt; 匹配除了0-9的任意字符</span><br></pre></td></tr></table></figure>
</li>
<li><p>代表数量的元字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ -&gt; 表示一个或多个，相当于&#123;1,&#125;</span><br><span class="line">? -&gt; 表示0个或1个，相当于&#123;0,1&#125;</span><br><span class="line">* -&gt; 表示任意数量，相当于&#123;0,&#125;</span><br><span class="line">&#123;m&#125; -&gt; 表示m个，相当于&#123;m,m&#125;</span><br><span class="line">&#123;m,&#125; -&gt; 表示至少m个</span><br><span class="line">&#123;m,n&#125; -&gt; 表示数量在m和n之间</span><br></pre></td></tr></table></figure>
</li>
<li><p>代表位置的元字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">^ -&gt; 匹配字符串开头，在多行中也匹配行开头</span><br><span class="line">$ -&gt; 匹配字符串末尾，在多场中也匹配行结尾</span><br><span class="line">\b -&gt; 匹配单词边界，具体表示\w和\W、\w和^、\w和$之间的位置</span><br><span class="line">\B -&gt; 匹配非单词边界，具体表示\w和\w、\W和\W、^和\W、\W和$之间的位置</span><br><span class="line">(?=p) -&gt; 匹配字符p前面的位置</span><br><span class="line">(?!p) -&gt; 匹配字符串p非前面的位置</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/images/zhengzhe1.png" width="70%"></p>
<p><img src="/images/zhengzhe2.png" width="70%"></p>
<p><img src="/images/zhengzhe3.png" width="70%"></p>
<p><img src="/images/zhengzhe4.png" width="70%"></p>
<p><img src="/images/zhengzhe5.png" width="70%"></p>
<h4 id="正则字符匹配实例"><a href="#正则字符匹配实例" class="headerlink" title="正则字符匹配实例"></a>正则字符匹配实例</h4><ol>
<li><p>横向模糊匹配</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const regex = /hello/;</span><br><span class="line">console.log(regex.test(&apos;hahahahelloworld&apos;)); //true</span><br><span class="line">// 检查字符串中是否含有&apos;hello&apos;</span><br><span class="line"></span><br><span class="line">const regex = /he&#123;3,5&#125;llo/;</span><br><span class="line">console.log(regex.test(&apos;heeello&apos;)) //true</span><br><span class="line">console.log(regex.test(&apos;heeeello&apos;)) //true</span><br><span class="line">console.log(regex.test(&apos;heeeeello&apos;)) //true</span><br><span class="line">console.log(regex.test(&apos;heeeeeello&apos;)) //false</span><br><span class="line">// 匹配e的数量3-5个</span><br></pre></td></tr></table></figure>
</li>
<li><p>纵向模糊匹配</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const regex = /a[123]b/;</span><br><span class="line">console.log(regex.test(&apos;a1b&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;a2b&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;a3b&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;a4b&apos;)); //false</span><br><span class="line">// [123]表示字符可以是1、2、3中任意一个</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>贪婪匹配<br> 顾名思义贪婪匹配就是尽可能匹配多的字符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const regex = /\d&#123;3,5&#125;/g;</span><br><span class="line">const string = &quot;123 1234 12345 123456&quot;;</span><br><span class="line">console.log(string.match(regex)); </span><br><span class="line">// =&gt; [&quot;123&quot;,&quot;1234&quot;,&quot;12345&quot;,&quot;12345&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性匹配<br> 顾名思义贪婪匹配就是尽可能匹配少的字符,格式就是在量词后面加个问号，比如{m,n}?</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const regex = /\d&#123;3,5&#125;?/g;</span><br><span class="line">const string = &quot;123 1234 12345 123456&quot;;</span><br><span class="line">console.log(string.match(regex)); </span><br><span class="line">// =&gt; [&quot;123&quot;,&quot;123&quot;,&quot;123&quot;,&quot;123&quot;,&quot;456&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>多选分支<br> 符号“|”，表示支持多个子匹配模式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const reagex = /dog|cat/g;</span><br><span class="line">const str = &apos;dog is pet, cat is pet&apos;;</span><br><span class="line">console.log(str.match(reagex))// [&apos;dog&apos;,&apos;cat&apos;]</span><br></pre></td></tr></table></figure>
<p> 注意：如果用/dog|dogcat/去匹配”dogcat”时结果是[“dog”]</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const reagex = /dog|dogcat/g;</span><br><span class="line">const str = &apos;dogcat dogcat&apos;;</span><br><span class="line">console.log(str.match(reagex))// [&apos;dog&apos;,&apos;dog&apos;]</span><br></pre></td></tr></table></figure>
<p> 由此可见分支匹配是惰性的</p>
</li>
<li><p>位置匹配</p>
<ul>
<li><p>^和$匹配(开头位置和结尾位置匹配)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /^|$/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // &quot;#hello.[world]#&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>\b 单词边界匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /\b/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // #hello#.[#world#]</span><br></pre></td></tr></table></figure>
</li>
<li><p>\B 非单词边界匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /\B/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // h#e#l#l#o.#[w#o#r#l#d]#</span><br></pre></td></tr></table></figure>
</li>
<li><p>(?=o) o字符前面位置匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /(?=o)/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // hell#o.[w#orld]</span><br></pre></td></tr></table></figure>
</li>
<li><p>(?!o) 除了o字符前面位置外所有位置匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /(?!o)/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // #h#e#l#lo#.#[#wo#r#l#d#]#</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>括号</p>
<p> 括号的作用：分组和引用</p>
<ul>
<li><p>分组功能：将多个字符组成一个整体，对这个整体进行匹配</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &quot;abab abbba ababab&quot;;</span><br><span class="line">const regex = /(ab)+/g;</span><br><span class="line">console.log(str.match(regex));// [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;]</span><br></pre></td></tr></table></figure>
<p>  使用括号将(ab)看成一个整体，对ab这个整体进行匹配，此外由结果可见”+”是贪婪匹配</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const regex = /^i love (cat|dog|monkey)$/;</span><br><span class="line">console.log(regex.test(&apos;i love cat&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;i love dog&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;i love monkey&apos;)); //true </span><br><span class="line">console.log(regex.test(&apos;i love pig&apos;)); //false</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用功能：<br>引用功能主要是提取匹配到的字符串，然后对其进行各种操作</p>
<ol>
<li><p>提取数据</p>
<p>比如：提取日期中的年、月、日</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;2019-03-01&apos;;</span><br><span class="line">const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">console.log(str.match(regex));</span><br><span class="line">// [&quot;2019-03-01&quot;, &quot;2019&quot;, &quot;03&quot;, &quot;01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined]</span><br><span class="line">console.log(RegExp.$1); // 2019</span><br><span class="line">console.log(RegExp.$2); // 03</span><br><span class="line">console.log(RegExp.$3); // 01</span><br><span class="line">console.log(RegExp.$4); // 空</span><br></pre></td></tr></table></figure>
<p>由此可见通过构造函数的全局属性$1-$9能获取匹配到的字符</p>
</li>
<li>数据操作<br>比如：将”2019-03-01”替换成”01-03-2019”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;2019-03-01&apos;;</span><br><span class="line">const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">const result = str.replace(regex, &quot;$3-$2-$1&quot;);</span><br><span class="line">const result2 = str.replace(regex, (match, $1, $2, $3) =&gt; &#123;</span><br><span class="line">    return $3 + &apos;-&apos; + $2 + &apos;-&apos; + $1 // match 返回匹配到的字符&quot;2019-03-01&quot;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result) // &quot;01-03-2019&quot;</span><br><span class="line">console.log(result2) // &quot;01-03-2019&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>反向引用<br>比如写一个正则匹配：’2019-03-01’,’2019/03/01’,’2019.03.01’</p>
<p>  第一反应可能是：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/; // 注意转义.和/;</span><br><span class="line">console.log(regex.test(&apos;2019-03-01&apos;)) // true</span><br><span class="line">console.log(regex.test(&apos;2019/03/01&apos;)) // true</span><br><span class="line">console.log(regex.test(&apos;2019.03.01&apos;)) //true</span><br><span class="line"></span><br><span class="line">console.log(regex.test(&apos;2019/03-01&apos;)) // true 这种错误的格式也匹配上了</span><br></pre></td></tr></table></figure>
<p>  由最后的结果可以知道这个正则并不完美，现在要解决的问题是如何保证日期分割符前后一致，此时可以使用反向引用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/; // 注意转义.和/,使用\1来引用前一个分组;</span><br><span class="line">console.log(regex.test(&apos;2019-03-01&apos;)) // true</span><br><span class="line">console.log(regex.test(&apos;2019/03/01&apos;)) // true</span><br><span class="line">console.log(regex.test(&apos;2019.03.01&apos;)) //true</span><br><span class="line"></span><br><span class="line">console.log(regex.test(&apos;2019/03-01&apos;)) // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向引用括号嵌套</p>
<p>  括号嵌套以左括号为准</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const regex = /^((\w)(\w(\w)))\1\2\3\4$/;</span><br><span class="line">const str = &quot;abcabcabcc&quot;;</span><br><span class="line">console.log(regex.test(str)); // true</span><br><span class="line">console.log(RegExp.$1); // abc</span><br><span class="line">console.log(RegExp.$2); // a</span><br><span class="line">console.log(RegExp.$3); // bc</span><br><span class="line">console.log(RegExp.$4); // c</span><br></pre></td></tr></table></figure>
<p>  分析：</p>
<blockquote>
<p>第一个”(“括号的分组内容是abc;</p>
</blockquote>
<blockquote>
<p>第二个”(“括号的分组内容是a;</p>
</blockquote>
<blockquote>
<p>第三个”(“括号的分组内容是bc;</p>
</blockquote>
<blockquote>
<p>第四个”(“括号的分组内容是c;</p>
</blockquote>
<p><img src="/images/yinyong.png" width="70%"></p>
</li>
<li><p>非捕获分组</p>
<p>  由前面的例子可以看出括号可以捕获匹配到的字符，然后用RegExp的api来访问捕获字符或者通过反向引用来访问捕获的字符，那么如果不想要捕获，只想要括号最原始的功能这时就可以使用非捕获分组(?:)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;2019-03-01&apos;;</span><br><span class="line">const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; // 捕获</span><br><span class="line">const regex2 = /(?:\d&#123;4&#125;)-(?:\d&#123;2&#125;)-(?:\d&#123;2&#125;)/; // 非捕获</span><br><span class="line">console.log(str.match(regex));</span><br><span class="line">// [&quot;2019-03-01&quot;, &quot;2019&quot;, &quot;03&quot;, &quot;01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">console.log(str.match(regex2)); </span><br><span class="line">// [&quot;2019-03-01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>
<p>  由上面实例可以看出使用非捕获分组(?:)就没有捕获到匹配的字符</p>
</li>
</ul>
</li>
</ol>
<h4 id="以上是本次所有总结的内容，想了解关于正则表达式回溯法原理等请查看原文，下一篇文章会试着写一些常见的正则案例"><a href="#以上是本次所有总结的内容，想了解关于正则表达式回溯法原理等请查看原文，下一篇文章会试着写一些常见的正则案例" class="headerlink" title="以上是本次所有总结的内容，想了解关于正则表达式回溯法原理等请查看原文，下一篇文章会试着写一些常见的正则案例"></a>以上是本次所有总结的内容，想了解关于正则表达式回溯法原理等请查看<a href="https://juejin.im/post/5965943ff265da6c30653879#heading-21" target="_blank" rel="noopener">原文</a>，下一篇文章会试着写一些常见的正则案例</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/21/js正则表达式/" data-id="cjtjgyco400047ua2aicj4ado" class="article-share-link">Share</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
    
      <a href="/2019/02/21/react-native-pushy实现Android和IOS热更新/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">react-native-pushy实现Android和IOS热更新</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2019 一只程序猪</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://zhwangart.github.io">zhwangart</a></li>
      <!--
      <li><a href="/">arvin</a></li>
      -->
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/pig.png" alt="一只程序猪"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>