<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只程序猪</title>
  
  <subtitle>爱二梦 | 爱生活 | 爱编程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-22T02:58:18.391Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>arvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js正则表达式</title>
    <link href="http://yoursite.com/2019/03/21/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/21/js正则表达式/</id>
    <published>2019-03-21T14:32:46.000Z</published>
    <updated>2019-03-22T02:58:18.391Z</updated>
    
    <content type="html"><![CDATA[<h4 id="此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文"><a href="#此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文" class="headerlink" title="此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文"></a>此文章是看完<a href="https://juejin.im/post/5965943ff265da6c30653879#heading-26" target="_blank" rel="noopener">老姚-JS正则表达式完整教程</a>之后整理的，原文写的通熟易懂，建议大家阅读原文</h4><h4 id="正则用处"><a href="#正则用处" class="headerlink" title="正则用处"></a>正则用处</h4><p>正则就是用来处理字符串的:主要有<strong>匹配</strong>和<strong>捕获</strong>两个功能</p><ul><li><p>匹配</p><p>  匹配字符串的格式是否符合既定的格式(正则的匹配)</p></li><li><p>捕获</p><p>  把一个字符串中符合既定格式的内容获取到(正则的捕获)</p></li></ul><h4 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h4><p>pattern 为RegExp实例，str为字符串</p> <!-- <img src="/images/table.png" width="100%" /> --><table><thead><tr><th style="text-align:center">用法</th><th style="text-align:center">说明</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">pattern.test(str)</td><td style="text-align:center">判断字符串是否包含匹配结果</td><td style="text-align:center">包含返回true，否则返回false</td></tr><tr><td style="text-align:center">pattern.exec(str)</td><td style="text-align:center">根据pattern对字符串进行正则匹配</td><td style="text-align:center">匹配成功返回匹配结果数组，匹配失败返回null</td></tr><tr><td style="text-align:center">str.match(str)</td><td style="text-align:center">根据pattern对字符串进行正则匹配</td><td style="text-align:center">匹配成功返回匹配结果数组，匹配失败返回null</td></tr><tr><td style="text-align:center">str.replace(pattern, replaceCallback或者str)</td><td style="text-align:center">根据pattern进行正则匹配，对匹配结果进行替换</td><td style="text-align:center">返回新的字符串</td></tr></tbody></table><h4 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h4><ul><li><p>特殊意义元字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\d -&gt; 匹配一个0-9的数字,相当于[0-9]</span><br><span class="line">\D -&gt; 匹配一个除了0-9的任意字符,相当于[^0-9]</span><br><span class="line">\w -&gt; 匹配一个0-9、a-z、A-Z、_的数字或字符,相当于[0-9a-zA-Z_]</span><br><span class="line">\W -&gt; 匹配非单词字符，相当于[^0-9a-zA-Z_]</span><br><span class="line">\s -&gt; 匹配一个空白字符(空格、制表符...)，相当于[ \t\v\n\r\f]</span><br><span class="line">\S -&gt; 匹配一个非空白字符，相当于[^ \t\v\n\r\f]</span><br><span class="line">. -&gt; 匹配一个任意字符，换行符、回车符、行分隔符、段分隔符除外，相当于[^\n\r\u2028\u2029]</span><br><span class="line">[abc] -&gt; 匹配a、b、c中任意一个字符</span><br><span class="line">[^abc] -&gt; 匹配除了a、b、c外任意一个字符</span><br><span class="line">[0-9] -&gt; 匹配0-9中的任意数字</span><br><span class="line">[^0-9] -&gt; 匹配除了0-9的任意字符</span><br></pre></td></tr></table></figure></li><li><p>代表数量的元字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ -&gt; 表示一个或多个，相当于&#123;1,&#125;</span><br><span class="line">? -&gt; 表示0个或1个，相当于&#123;0,1&#125;</span><br><span class="line">* -&gt; 表示任意数量，相当于&#123;0,&#125;</span><br><span class="line">&#123;m&#125; -&gt; 表示m个，相当于&#123;m,m&#125;</span><br><span class="line">&#123;m,&#125; -&gt; 表示至少m个</span><br><span class="line">&#123;m,n&#125; -&gt; 表示数量在m和n之间</span><br></pre></td></tr></table></figure></li><li><p>代表位置的元字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">^ -&gt; 匹配字符串开头，在多行中也匹配行开头</span><br><span class="line">$ -&gt; 匹配字符串末尾，在多场中也匹配行结尾</span><br><span class="line">\b -&gt; 匹配单词边界，具体表示\w和\W、\w和^、\w和$之间的位置</span><br><span class="line">\B -&gt; 匹配非单词边界，具体表示\w和\w、\W和\W、^和\W、\W和$之间的位置</span><br><span class="line">(?=p) -&gt; 匹配字符p前面的位置</span><br><span class="line">(?!p) -&gt; 匹配字符串p非前面的位置</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/zhengzhe1.png" width="70%"></p><p><img src="/images/zhengzhe2.png" width="70%"></p><p><img src="/images/zhengzhe3.png" width="70%"></p><p><img src="/images/zhengzhe4.png" width="70%"></p><p><img src="/images/zhengzhe5.png" width="70%"></p><h4 id="正则字符匹配实例"><a href="#正则字符匹配实例" class="headerlink" title="正则字符匹配实例"></a>正则字符匹配实例</h4><ol><li><p>横向模糊匹配</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const regex = /hello/;</span><br><span class="line">console.log(regex.test(&apos;hahahahelloworld&apos;)); //true</span><br><span class="line">// 检查字符串中是否含有&apos;hello&apos;</span><br><span class="line"></span><br><span class="line">const regex = /he&#123;3,5&#125;llo/;</span><br><span class="line">console.log(regex.test(&apos;heeello&apos;)) //true</span><br><span class="line">console.log(regex.test(&apos;heeeello&apos;)) //true</span><br><span class="line">console.log(regex.test(&apos;heeeeello&apos;)) //true</span><br><span class="line">console.log(regex.test(&apos;heeeeeello&apos;)) //false</span><br><span class="line">// 匹配e的数量3-5个</span><br></pre></td></tr></table></figure></li><li><p>纵向模糊匹配</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const regex = /a[123]b/;</span><br><span class="line">console.log(regex.test(&apos;a1b&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;a2b&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;a3b&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;a4b&apos;)); //false</span><br><span class="line">// [123]表示字符可以是1、2、3中任意一个</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>贪婪匹配<br> 顾名思义贪婪匹配就是尽可能匹配多的字符</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const regex = /\d&#123;3,5&#125;/g;</span><br><span class="line">const string = &quot;123 1234 12345 123456&quot;;</span><br><span class="line">console.log(string.match(regex)); </span><br><span class="line">// =&gt; [&quot;123&quot;,&quot;1234&quot;,&quot;12345&quot;,&quot;12345&quot;]</span><br></pre></td></tr></table></figure></li><li><p>惰性匹配<br> 顾名思义贪婪匹配就是尽可能匹配少的字符,格式就是在量词后面加个问号，比如{m,n}?</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const regex = /\d&#123;3,5&#125;?/g;</span><br><span class="line">const string = &quot;123 1234 12345 123456&quot;;</span><br><span class="line">console.log(string.match(regex)); </span><br><span class="line">// =&gt; [&quot;123&quot;,&quot;123&quot;,&quot;123&quot;,&quot;123&quot;,&quot;456&quot;]</span><br></pre></td></tr></table></figure></li><li><p>多选分支<br> 符号“|”，表示支持多个子匹配模式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const reagex = /dog|cat/g;</span><br><span class="line">const str = &apos;dog is pet, cat is pet&apos;;</span><br><span class="line">console.log(str.match(reagex))// [&apos;dog&apos;,&apos;cat&apos;]</span><br></pre></td></tr></table></figure><p> 注意：如果用/dog|dogcat/去匹配”dogcat”时结果是[“dog”]</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const reagex = /dog|dogcat/g;</span><br><span class="line">const str = &apos;dogcat dogcat&apos;;</span><br><span class="line">console.log(str.match(reagex))// [&apos;dog&apos;,&apos;dog&apos;]</span><br></pre></td></tr></table></figure><p> 由此可见分支匹配是惰性的</p></li><li><p>位置匹配</p><ul><li><p>^和$匹配(开头位置和结尾位置匹配)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /^|$/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // &quot;#hello.[world]#&quot;</span><br></pre></td></tr></table></figure></li><li><p>\b 单词边界匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /\b/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // #hello#.[#world#]</span><br></pre></td></tr></table></figure></li><li><p>\B 非单词边界匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /\B/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // h#e#l#l#o.#[w#o#r#l#d]#</span><br></pre></td></tr></table></figure></li><li><p>(?=o) o字符前面位置匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /(?=o)/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // hell#o.[w#orld]</span><br></pre></td></tr></table></figure></li><li><p>(?!o) 除了o字符前面位置外所有位置匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello.[world]&apos;;</span><br><span class="line">const regex = /(?!o)/g;</span><br><span class="line">console.log(str.replace(regex, &apos;#&apos;)); // #h#e#l#lo#.#[#wo#r#l#d#]#</span><br></pre></td></tr></table></figure></li></ul></li><li><p>括号</p><p> 括号的作用：分组和引用</p><ul><li><p>分组功能：将多个字符组成一个整体，对这个整体进行匹配</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &quot;abab abbba ababab&quot;;</span><br><span class="line">const regex = /(ab)+/g;</span><br><span class="line">console.log(str.match(regex));// [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;]</span><br></pre></td></tr></table></figure><p>  使用括号将(ab)看成一个整体，对ab这个整体进行匹配，此外由结果可见”+”是贪婪匹配</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const regex = /^i love (cat|dog|monkey)$/;</span><br><span class="line">console.log(regex.test(&apos;i love cat&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;i love dog&apos;)); //true</span><br><span class="line">console.log(regex.test(&apos;i love monkey&apos;)); //true </span><br><span class="line">console.log(regex.test(&apos;i love pig&apos;)); //false</span><br></pre></td></tr></table></figure></li><li><p>引用功能：<br>引用功能主要是提取匹配到的字符串，然后对其进行各种操作</p><ol><li><p>提取数据</p><p>比如：提取日期中的年、月、日</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;2019-03-01&apos;;</span><br><span class="line">const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">console.log(str.match(regex));</span><br><span class="line">// [&quot;2019-03-01&quot;, &quot;2019&quot;, &quot;03&quot;, &quot;01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined]</span><br><span class="line">console.log(RegExp.$1); // 2019</span><br><span class="line">console.log(RegExp.$2); // 03</span><br><span class="line">console.log(RegExp.$3); // 01</span><br><span class="line">console.log(RegExp.$4); // 空</span><br></pre></td></tr></table></figure><p>由此可见通过构造函数的全局属性$1-$9能获取匹配到的字符</p></li><li>数据操作<br>比如：将”2019-03-01”替换成”01-03-2019”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;2019-03-01&apos;;</span><br><span class="line">const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">const result = str.replace(regex, &quot;$3-$2-$1&quot;);</span><br><span class="line">const result2 = str.replace(regex, (match, $1, $2, $3) =&gt; &#123;</span><br><span class="line">    return $3 + &apos;-&apos; + $2 + &apos;-&apos; + $1 // match 返回匹配到的字符&quot;2019-03-01&quot;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result) // &quot;01-03-2019&quot;</span><br><span class="line">console.log(result2) // &quot;01-03-2019&quot;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>反向引用<br>比如写一个正则匹配：’2019-03-01’,’2019/03/01’,’2019.03.01’</p><p>  第一反应可能是：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/; // 注意转义.和/;</span><br><span class="line">console.log(regex.test(&apos;2019-03-01&apos;)) // true</span><br><span class="line">console.log(regex.test(&apos;2019/03/01&apos;)) // true</span><br><span class="line">console.log(regex.test(&apos;2019.03.01&apos;)) //true</span><br><span class="line"></span><br><span class="line">console.log(regex.test(&apos;2019/03-01&apos;)) // true 这种错误的格式也匹配上了</span><br></pre></td></tr></table></figure><p>  由最后的结果可以知道这个正则并不完美，现在要解决的问题是如何保证日期分割符前后一致，此时可以使用反向引用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/; // 注意转义.和/,使用\1来引用前一个分组;</span><br><span class="line">console.log(regex.test(&apos;2019-03-01&apos;)) // true</span><br><span class="line">console.log(regex.test(&apos;2019/03/01&apos;)) // true</span><br><span class="line">console.log(regex.test(&apos;2019.03.01&apos;)) //true</span><br><span class="line"></span><br><span class="line">console.log(regex.test(&apos;2019/03-01&apos;)) // false</span><br></pre></td></tr></table></figure></li><li><p>反向引用括号嵌套</p><p>  括号嵌套以左括号为准</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const regex = /^((\w)(\w(\w)))\1\2\3\4$/;</span><br><span class="line">const str = &quot;abcabcabcc&quot;;</span><br><span class="line">console.log(regex.test(str)); // true</span><br><span class="line">console.log(RegExp.$1); // abc</span><br><span class="line">console.log(RegExp.$2); // a</span><br><span class="line">console.log(RegExp.$3); // bc</span><br><span class="line">console.log(RegExp.$4); // c</span><br></pre></td></tr></table></figure><p>  分析：</p><blockquote><p>第一个”(“括号的分组内容是abc;</p></blockquote><blockquote><p>第二个”(“括号的分组内容是a;</p></blockquote><blockquote><p>第三个”(“括号的分组内容是bc;</p></blockquote><blockquote><p>第四个”(“括号的分组内容是c;</p></blockquote><p><img src="/images/yinyong.png" width="70%"></p></li><li><p>非捕获分组</p><p>  由前面的例子可以看出括号可以捕获匹配到的字符，然后用RegExp的api来访问捕获字符或者通过反向引用来访问捕获的字符，那么如果不想要捕获，只想要括号最原始的功能这时就可以使用非捕获分组(?:)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;2019-03-01&apos;;</span><br><span class="line">const regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; // 捕获</span><br><span class="line">const regex2 = /(?:\d&#123;4&#125;)-(?:\d&#123;2&#125;)-(?:\d&#123;2&#125;)/; // 非捕获</span><br><span class="line">console.log(str.match(regex));</span><br><span class="line">// [&quot;2019-03-01&quot;, &quot;2019&quot;, &quot;03&quot;, &quot;01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">console.log(str.match(regex2)); </span><br><span class="line">// [&quot;2019-03-01&quot;, index: 0, input: &quot;2019-03-01&quot;, groups: undefined]</span><br></pre></td></tr></table></figure><p>  由上面实例可以看出使用非捕获分组(?:)就没有捕获到匹配的字符</p></li></ul></li></ol><h4 id="以上是本次所有总结的内容，想了解关于正则表达式回溯法原理等请查看原文，下一篇文章会试着写一些常见的正则案例"><a href="#以上是本次所有总结的内容，想了解关于正则表达式回溯法原理等请查看原文，下一篇文章会试着写一些常见的正则案例" class="headerlink" title="以上是本次所有总结的内容，想了解关于正则表达式回溯法原理等请查看原文，下一篇文章会试着写一些常见的正则案例"></a>以上是本次所有总结的内容，想了解关于正则表达式回溯法原理等请查看<a href="https://juejin.im/post/5965943ff265da6c30653879#heading-21" target="_blank" rel="noopener">原文</a>，下一篇文章会试着写一些常见的正则案例</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文&quot;&gt;&lt;a href=&quot;#此文章是看完老姚-JS正则表达式完整教程之后整理的，原文写的通熟易懂，建议大家阅读原文&quot; class=&quot;headerlink&quot; title=&quot;此文章是看完
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react-native-pushy实现Android和IOS热更新</title>
    <link href="http://yoursite.com/2019/02/21/react-native-pushy%E5%AE%9E%E7%8E%B0Android%E5%92%8CIOS%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2019/02/21/react-native-pushy实现Android和IOS热更新/</id>
    <published>2019-02-21T05:08:24.000Z</published>
    <updated>2019-02-21T10:19:59.521Z</updated>
    
    <content type="html"><![CDATA[<h4 id="热更新主要是用来更新JS和图片，就是在不重新安装应用的情况下，完成JS和图片的更新，如果是要更新原生层代码那么还是要重新安装应用的"><a href="#热更新主要是用来更新JS和图片，就是在不重新安装应用的情况下，完成JS和图片的更新，如果是要更新原生层代码那么还是要重新安装应用的" class="headerlink" title="热更新主要是用来更新JS和图片，就是在不重新安装应用的情况下，完成JS和图片的更新，如果是要更新原生层代码那么还是要重新安装应用的"></a>热更新主要是用来更新JS和图片，就是在不重新安装应用的情况下，完成JS和图片的更新，如果是要更新原生层代码那么还是要重新安装应用的</h4><h4 id="react-native-pushy：github"><a href="#react-native-pushy：github" class="headerlink" title="react-native-pushy：github"></a>react-native-pushy：<a href="https://github.com/reactnativecn/react-native-pushy" target="_blank" rel="noopener">github</a></h4><h4 id="update服务：地址"><a href="#update服务：地址" class="headerlink" title="update服务：地址"></a>update服务：<a href="http://update.reactnative.cn/home" target="_blank" rel="noopener">地址</a></h4><h4 id="配置和集成参考文章："><a href="#配置和集成参考文章：" class="headerlink" title="配置和集成参考文章："></a>配置和集成参考文章：</h4><p>官方文档：<a href="https://github.com/reactnativecn/react-native-pushy/blob/master/README.md" target="_blank" rel="noopener">地址</a></p><p>CSDN 热更新 Android: <a href="https://blog.csdn.net/dongdong230/article/details/52625157" target="_blank" rel="noopener">地址</a></p><p>CSDN 热更新 IOS: <a href="https://blog.csdn.net/dongdong230/article/details/52638541" target="_blank" rel="noopener">地址</a></p><p>简书：<a href="https://www.jianshu.com/p/117399ba4795" target="_blank" rel="noopener">地址</a></p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h4><ul><li>如果RN版本小于0.45，需要先安装Android NDK(版本推荐r10e)，并设置环境变量ANDROID_NDK_HOME指向你的根目录</li><li>如果RN版本是0.46以上那么不需要安装NDK</li></ul><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g react-native-update-cli //同一台电脑只需要执行一次</span><br><span class="line">npm i react-native-update@具体版本请参考官网</span><br><span class="line">react-native link react-native-update</span><br></pre></td></tr></table></figure><h4 id="手动link"><a href="#手动link" class="headerlink" title="手动link"></a>手动link</h4><p>如果<code>react-native link react-native-update</code>执行成功，则不需要手动link</p><h4 id="ios手动link"><a href="#ios手动link" class="headerlink" title="ios手动link"></a>ios手动link</h4><ul><li>在XCode中的Project Navigator里,右键点击Libraries -&gt; Add Files to [你的工程名]</li><li>进入项目node_modules文件夹找到react-native-update里ios文件夹下的RCTHotUpdate.xcodeproj文件并选中</li><li>在项目的 Build Phases 找到 Link Binary With Libraries 点击下方的 + 加号<br>依次添加 RCTHotUpdate.a 和 libz.tbd 还有 libbz2.1.0.tbd</li><li>继续在Build Settings里搜索Header Search Path，添加$(SRCROOT)/../node_modules/react-native-update/ios</li></ul><h4 id="android手动link"><a href="#android手动link" class="headerlink" title="android手动link"></a>android手动link</h4><ol><li><p>在<code>android/settings.gradle</code>中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:react-native-update&apos;</span><br><span class="line">project(&apos;:react-native-update&apos;).projectDir = new File(rootProject.projectDir,   &apos;../node_modules/react-native-update/android&apos;)</span><br></pre></td></tr></table></figure></li><li><p>在<code>android/app/build.gradle</code> dependencies部分增加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile project(&apos;:react-native-update&apos;)</span><br></pre></td></tr></table></figure></li><li><p>打开<code>android/app/src/main/java/[...]/MainApplication.java</code>,在文件开头增加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import cn.reactnative.modules.update.UpdatePackage</span><br></pre></td></tr></table></figure></li><li><p>在<code>getPackages()</code> 方法中增加 <code>new UpdatePackage()</code>(注意上一行可能要增加一个逗号)</p></li></ol><h4 id="配置Bundle-Url"><a href="#配置Bundle-Url" class="headerlink" title="配置Bundle Url"></a>配置Bundle Url</h4><h4 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h4><p>打开AppDelegate.m文件增加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if DEBUG</span><br><span class="line">  // 原来的jsCodeLocation</span><br><span class="line">#else</span><br><span class="line">  jsCodeLocation=[RCTHotUpdate bundleURL];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>在你的<code>android/app/src/main/java/[...]/MainApplication.java</code>中增加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ... 其它代码</span><br><span class="line"></span><br><span class="line">// 请注意不要少了这句import</span><br><span class="line">import cn.reactnative.modules.update.UpdateContext;</span><br><span class="line">public class MainApplication extends Application implements ReactApplication &#123;</span><br><span class="line"></span><br><span class="line">  private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected String getJSBundleFile() &#123;</span><br><span class="line">        return UpdateContext.getBundleUrl(MainApplication.this);</span><br><span class="line">    &#125;</span><br><span class="line">    // ... 其它代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ios的ATS例外配置"><a href="#ios的ATS例外配置" class="headerlink" title="ios的ATS例外配置"></a>ios的ATS例外配置</h4><p>从iOS9开始，苹果要求以白名单的形式在Info.plist中列出外部的非https接口，以督促开发者部署https协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;NSExceptionDomains&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;reactnative.cn&lt;/key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;</span><br><span class="line">            &lt;true/&gt;</span><br><span class="line">            &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt;</span><br><span class="line">            &lt;true/&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">   &lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p><h4 id="在Update服务中创建应用"><a href="#在Update服务中创建应用" class="headerlink" title="在Update服务中创建应用"></a>在<a href="http://update.reactnative.cn/home" target="_blank" rel="noopener">Update服务</a>中创建应用</h4><ol><li>先注册账号<a href="http://update.reactnative.cn" target="_blank" rel="noopener">http://update.reactnative.cn</a></li><li>在项目根目录下开启终端，然后执行<code>pushy login</code>命令，输入邮箱和密码，回车登录</li><li>登录之后项目根目录下会有<code>.update</code>文件(注意不要把这个文件上传到git或者svn)</li></ol><p>登录之后可以创建应用，创建方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pushy createApp --platform ios //创建ios应用</span><br><span class="line">$ pushy createApp --platform android //创建android应用</span><br></pre></td></tr></table></figure></p><p>常用操作命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pushy login //登录</span><br><span class="line">$ pushy createApp --platform [ios/android] //创建应用</span><br><span class="line">$ pushy selectApp --platform [ios/android] //选择应用</span><br><span class="line">$ pushy bundle --platform [ios/android] //发布热更新版本</span><br><span class="line">$ pushy uploadIpa [ipa地址] //上传ios应用，用作版本对比</span><br><span class="line">$ pushy uploadApk [apk地址] //上传android应用，用作版本对比</span><br></pre></td></tr></table></figure></p><p>配置应用层更新时下载应用的地址：</p><ol><li>登录 <a href="http://update.reactnative.cn" target="_blank" rel="noopener">http://update.reactnative.cn</a></li><li>进入你的应用</li><li>点击顶部导航栏的【设置】，配置下载地址</li></ol><h4 id="JS端集成代码"><a href="#JS端集成代码" class="headerlink" title="JS端集成代码"></a>JS端集成代码</h4><h4 id="1-获取appKey"><a href="#1-获取appKey" class="headerlink" title="1. 获取appKey"></a>1. 获取appKey</h4><p>检查更新时必须提供你的appKey，这个值保存在update.json中，并且根据平台不同而不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Platform &#125; from &apos;reactNative&apos;;</span><br><span class="line">import _updateConfig from &apos;./update.json&apos;;</span><br><span class="line">const &#123;appKey&#125; = _updateConfig[Platform.OS];</span><br></pre></td></tr></table></figure><h4 id="2-检查更新"><a href="#2-检查更新" class="headerlink" title="2. 检查更新"></a>2. 检查更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">checkUpdate = () =&gt; &#123;</span><br><span class="line">  checkUpdate(appKey).then(info =&gt; &#123;</span><br><span class="line">    if (info.expired) &#123; //检测到应用层更新</span><br><span class="line">      // info.downloadUrl就是在网站中配置的下载地址</span><br><span class="line">      Alert.alert(&apos;提示&apos;, &apos;您的应用版本已更新,请前往应用商店下载新的版本&apos;, [</span><br><span class="line">        &#123;text: &apos;确定&apos;, onPress: () =&gt; &#123;info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)&#125;&#125;,</span><br><span class="line">      ], &#123; onDismiss: () =&gt; &#123; console.log(&apos;取消&apos;) &#125;&#125;);</span><br><span class="line">    &#125; else if (info.upToDate) &#123;</span><br><span class="line">      // 检测到版本已经时最新</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 检测到热更新</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&apos;updatefailed===&apos;, err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-下载更新、切换版本"><a href="#3-下载更新、切换版本" class="headerlink" title="3. 下载更新、切换版本"></a>3. 下载更新、切换版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">doUpdate = (info) =&gt; &#123;</span><br><span class="line">  downloadUpdate(info).then(hash =&gt; &#123;</span><br><span class="line">    if (hash) &#123;</span><br><span class="line">        Alert.alert(&apos;提示&apos;, &apos;下载完毕,是否重启应用?&apos;, [</span><br><span class="line">            &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;switchVersion(hash);&#125;&#125;,</span><br><span class="line">            &#123;text: &apos;否&apos;,&#125;,</span><br><span class="line">            &#123;text: &apos;下次启动时&apos;, onPress: ()=&gt;&#123;switchVersionLater(hash);&#125;&#125;,</span><br><span class="line">          ]);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&apos;提示&apos;, &apos;更新失败.&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-关于首次启动、回滚"><a href="#4-关于首次启动、回滚" class="headerlink" title="4. 关于首次启动、回滚"></a>4. 关于首次启动、回滚</h4><p>在每次更新完毕后的首次启动时，isFirstTime常量会为true。 <font color="#ff0000">你必须在应用退出前合适的任何时机，调用markSuccess，否则应用下一次启动的时候将会进行回滚操作</font>。 这一机制称作“反触发”，这样当你应用启动初期即遭遇问题的时候，也能在下一次启动时恢复运作。</p><p>你可以通过isFirstTime来获知这是当前版本的首次启动，也可以通过isRolledBack来获知应用刚刚经历了一次回滚操作。 你可以在此时给予用户合理的提示。</p><h4 id="5-核心代码示例"><a href="#5-核心代码示例" class="headerlink" title="5.核心代码示例"></a>5.核心代码示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    ...</span><br><span class="line">    Platform,</span><br><span class="line">    ...</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">  isFirstTime,</span><br><span class="line">  isRolledBack,</span><br><span class="line">  packageVersion,</span><br><span class="line">  currentVersion,</span><br><span class="line">  checkUpdate,</span><br><span class="line">  downloadUpdate,</span><br><span class="line">  switchVersion,</span><br><span class="line">  switchVersionLater,</span><br><span class="line">  markSuccess,</span><br><span class="line">&#125; from &apos;react-native-update&apos;;</span><br><span class="line">...</span><br><span class="line">import _updateConfig from &apos;./update.json&apos;;</span><br><span class="line">const &#123;appKey&#125; = _updateConfig[Platform.OS];</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">componentWillMount()&#123;</span><br><span class="line">    if (isFirstTime) &#123;</span><br><span class="line">      Alert.alert(&apos;提示&apos;, &apos;这是当前版本第一次启动,是否要模拟启动失败?失败将回滚到上一版本&apos;, [</span><br><span class="line">        &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;throw new Error(&apos;模拟启动失败,请重启应用&apos;)&#125;&#125;,</span><br><span class="line">        &#123;text: &apos;否&apos;, onPress: ()=&gt;&#123;markSuccess()&#125;&#125;,</span><br><span class="line">      ]);</span><br><span class="line">    &#125; else if (isRolledBack) &#123;</span><br><span class="line">      Alert.alert(&apos;提示&apos;, &apos;刚刚更新失败了,版本被回滚.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  doUpdate = info =&gt; &#123;</span><br><span class="line">    downloadUpdate(info).then(hash =&gt; &#123;</span><br><span class="line">      Alert.alert(&apos;提示&apos;, &apos;下载完毕,是否重启应用?&apos;, [</span><br><span class="line">        &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;switchVersion(hash);&#125;&#125;,</span><br><span class="line">        &#123;text: &apos;否&apos;,&#125;,</span><br><span class="line">        &#123;text: &apos;下次启动时&apos;, onPress: ()=&gt;&#123;switchVersionLater(hash);&#125;&#125;,</span><br><span class="line">      ]);</span><br><span class="line">    &#125;).catch(err =&gt; &#123; </span><br><span class="line">      Alert.alert(&apos;提示&apos;, &apos;更新失败.&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  checkUpdate = () =&gt; &#123;</span><br><span class="line">    checkUpdate(appKey).then(info =&gt; &#123;</span><br><span class="line">      if (info.expired) &#123;</span><br><span class="line">        Alert.alert(&apos;提示&apos;, &apos;您的应用版本已更新,请前往应用商店下载新的版本&apos;, [</span><br><span class="line">          &#123;text: &apos;确定&apos;, onPress: ()=&gt;&#123;info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)&#125;&#125;,</span><br><span class="line">        ]);</span><br><span class="line">      &#125; else if (info.upToDate) &#123;</span><br><span class="line">        Alert.alert(&apos;提示&apos;, &apos;您的应用版本已是最新.&apos;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Alert.alert(&apos;提示&apos;, &apos;检查到新的版本&apos;+info.name+&apos;,是否下载?\n&apos;+ info.description, [</span><br><span class="line">          &#123;text: &apos;是&apos;, onPress: ()=&gt;&#123;this.doUpdate(info)&#125;&#125;,</span><br><span class="line">          &#123;text: &apos;否&apos;,&#125;,</span><br><span class="line">        ]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catch(err =&gt; &#123; </span><br><span class="line">      Alert.alert(&apos;提示&apos;, &apos;更新失败.&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h4 id="Android-原生层代码更新，自动下载、安装apk实现："><a href="#Android-原生层代码更新，自动下载、安装apk实现：" class="headerlink" title="Android 原生层代码更新，自动下载、安装apk实现："></a>Android 原生层代码更新，自动下载、安装apk实现：</h4><h4 id="准备工作：-1"><a href="#准备工作：-1" class="headerlink" title="准备工作："></a>准备工作：</h4><ul><li>安装第三方依赖：<a href="https://github.com/itinance/react-native-fs" target="_blank" rel="noopener">react-native-fs</a>、<a href="https://github.com/flare216/react-native-install-apk" target="_blank" rel="noopener">react-native-install-apk</a></li><li>开放android读写文件权限</li></ul><p>打开 android/app/src/main/AndroidManifest.xml添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    ......</span><br><span class="line">    NativeModules</span><br><span class="line"> &#125; from &apos;react-native&apos;;</span><br><span class="line"> import RNFS from &apos;react-native-fs&apos;;</span><br><span class="line"> ......</span><br><span class="line"> ......</span><br><span class="line"> checkUpdate(appKey).then(info =&gt; &#123; //热更新检查</span><br><span class="line">  if (info.expired) &#123; //检查原生层代码更新</span><br><span class="line">    if (info.downloadUrl) &#123; // 如果在update服务中配置了应用下载地址</span><br><span class="line">      RNFS.mkdir(&quot;/sdcard/yymedic&quot;).then(() =&gt; &#123;</span><br><span class="line">        const filePath = RNFS.ExternalStorageDirectoryPath + &quot;/yymedic/yy-nurse.apk&quot;;</span><br><span class="line">        const download = RNFS.downloadFile(&#123;</span><br><span class="line">          fromUrl: info.downloadUrl,</span><br><span class="line">          toFile: filePath,</span><br><span class="line">          progress: res =&gt; &#123; // 下载进度</span><br><span class="line">            that.setState(&#123; downloadProgress: ((res.bytesWritten / res.contentLength) * 100).toFixed(2) &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          progressDivider: 1 // 下载进度回调的步频，比如10，那么进度在0、10、20....处触发回调</span><br><span class="line">        &#125;);</span><br><span class="line">        download.promise.then(result =&gt; &#123;</span><br><span class="line">          if (result.statusCode == 200) &#123;</span><br><span class="line">            that.setState(&#123; downloadProgress: 0, updating: false &#125;);</span><br><span class="line">            NativeModules.InstallApk.install(filePath); // 下载成功之后安装apk</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            Toast.info(&apos;更新失败&apos;, 1);</span><br><span class="line">            that.setState(&#123; downloadProgress: 0, updating: false &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(err =&gt; &#123;</span><br><span class="line">          Toast.info(&apos;更新失败&apos;, 1);</span><br><span class="line">          that.setState(&#123; downloadProgress: 0, updating: false &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;).catch(err =&gt; &#123;</span><br><span class="line">        Toast.info(&apos;更新失败&apos;, 1);</span><br><span class="line">        that.setState(&#123; updating: false &#125;);</span><br><span class="line">        console.log(&apos;提示&apos;, &apos;更新失败.&apos;, err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      that.setState(&#123; updating: false &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (info.upToDate) &#123;</span><br><span class="line">    // 如果是最新的，则执行其他操作</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 热更新代码逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  Toast.info(&apos;更新失败&apos;, 1);</span><br><span class="line">  console.log(&apos;提示&apos;, &apos;更新失败.&apos;, err);</span><br><span class="line">&#125;);</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;热更新主要是用来更新JS和图片，就是在不重新安装应用的情况下，完成JS和图片的更新，如果是要更新原生层代码那么还是要重新安装应用的&quot;&gt;&lt;a href=&quot;#热更新主要是用来更新JS和图片，就是在不重新安装应用的情况下，完成JS和图片的更新，如果是要更新原生层代码那么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react-native开发碰到的问题及插件整理</title>
    <link href="http://yoursite.com/2019/02/19/react-native%E5%BC%80%E5%8F%91%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/19/react-native开发碰到的问题及插件整理/</id>
    <published>2019-02-19T06:58:24.000Z</published>
    <updated>2019-02-19T07:10:51.422Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-uncompiled-PNG-file"><a href="#1-uncompiled-PNG-file" class="headerlink" title="1. uncompiled PNG file"></a>1. uncompiled PNG file</h4><p>描述：该问题出现在打包成release apk的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Users/almouro/bam/uefa/TestGradle3/android/app/build/intermediates/res/merged/release/drawable-mdpi/image.png: error: uncompiled PNG file passed as argument. Must be compiled first into .flat file..</span><br><span class="line">error: failed parsing overlays.</span><br></pre></td></tr></table></figure></p><p>解决方法：<br>打开 <code>android/gradle.properties</code> 文件添加 <code>android.enableAapt2=false</code> </p><p>查看: <a href="https://github.com/facebook/react-native/issues/16906" target="_blank" rel="noopener">github issues uncompiled PNG file</a></p><h4 id="2-react-native-modal-组件"><a href="#2-react-native-modal-组件" class="headerlink" title="2. react-native modal 组件"></a>2. react-native modal 组件</h4><p>描述： 在使用react-native modal 组件的时候发现模态框并没有覆盖到手机状态栏</p><p>解决方法：<a href="https://github.com/listenzz/react-native-modal-translucent" target="_blank" rel="noopener">react-native-modal-translucent</a></p><h4 id="3-react-native-键盘弹出导致绝对定位元素上浮"><a href="#3-react-native-键盘弹出导致绝对定位元素上浮" class="headerlink" title="3. react-native 键盘弹出导致绝对定位元素上浮"></a>3. react-native 键盘弹出导致绝对定位元素上浮</h4><p>描述：当软键盘通过textInput组件唤起的时候，绝对定位元素上浮</p><p>解决方法：打开<code>AndroidManifest.xml</code>文件修改<code>activity</code> 中的 <code>android:windowSoftinputMode=&quot;stateAlwaysHidden|adjustpan&quot;</code></p><p>参考连接：<a href="https://394498036.iteye.com/blog/2393507" target="_blank" rel="noopener">原文</a></p><p>windowSoftinputMode介绍：<a href="https://developer.android.com/guide/topics/manifest/activity-element" target="_blank" rel="noopener">Developers</a></p><h4 id="4-react-native-软键盘遮住textInput"><a href="#4-react-native-软键盘遮住textInput" class="headerlink" title="4. react-native 软键盘遮住textInput"></a>4. react-native 软键盘遮住textInput</h4><p>描述：当页面有多个 textInput 输入框，底部输入框唤起软键盘时会被遮住</p><p>解决方法：<a href="https://github.com/APSL/react-native-keyboard-aware-scroll-view" target="_blank" rel="noopener">react-native-keyboard-aware-scroll-view</a></p><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; KeyboardAwareScrollView &#125; from &apos;react-native-keyboard-aware-scroll-view&apos;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;KeyboardAwareScrollView&gt;</span><br><span class="line">  &lt;View&gt;</span><br><span class="line">    &lt;TextInput /&gt;</span><br><span class="line">    &lt;TextInput /&gt;</span><br><span class="line">    &lt;TextInput /&gt;</span><br><span class="line">  &lt;/View&gt;</span><br><span class="line">&lt;/KeyboardAwareScrollView&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="5-react-native-蓝牙通信"><a href="#5-react-native-蓝牙通信" class="headerlink" title="5. react-native 蓝牙通信"></a>5. react-native 蓝牙通信</h4><p>描述：蓝牙分两种通信模式(BEL蓝牙 和 经典蓝牙)，对于BLE蓝牙推荐使用react-native-ble-manager 组件，对于经典蓝牙推荐使用react-native-bluetooth-serial</p><p>解决方法：</p><p>BLE蓝牙：<a href="https://github.com/innoveit/react-native-ble-manager" target="_blank" rel="noopener">react-native-ble-manager</a></p><p>经典蓝牙: <a href="https://github.com/rusel1989/react-native-bluetooth-serial" target="_blank" rel="noopener">react-native-bluetooth-serial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-uncompiled-PNG-file&quot;&gt;&lt;a href=&quot;#1-uncompiled-PNG-file&quot; class=&quot;headerlink&quot; title=&quot;1. uncompiled PNG file&quot;&gt;&lt;/a&gt;1. uncompiled PNG file
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>setMonth导致获取月份错误</title>
    <link href="http://yoursite.com/2019/02/12/setMonth%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/12/setMonth问题/</id>
    <published>2019-02-12T06:28:14.000Z</published>
    <updated>2019-02-21T07:41:07.513Z</updated>
    
    <content type="html"><![CDATA[<ol><li>问题重现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> // 比如今天是 2017-03-31 号，理论上后推一个月应该是4月   </span><br><span class="line">let now = new Date(new Date(&quot;2017-03-31&quot;).setMonth(new Date(&quot;2017-03-31&quot;).getMonth() + 1))</span><br><span class="line">console.log(&apos;now :&apos;, now.getMonth())</span><br><span class="line">// 结果是：now : 2017/5/1 上午8:00:00</span><br></pre></td></tr></table></figure><pre><code>实际的结果和预想的结果不一致！！</code></pre><p><strong>MDN解释：</strong></p><blockquote><p>If you do not specify the dayValue parameter, the value returned from the getDate() method is used.<br><br><br>If a parameter you specify is outside of the expected range, setMonth() attempts to update the date information in the Date object accordingly. For example, if you use 15 for monthValue, the year will be incremented by 1, and 3 will be used for month.<br><br><br>The current day of month will have an impact on the behaviour of this method. Conceptually it will add the number of days given by the current day of the month to the 1st day of the new month specified as the parameter, to return the new date. For example, if the current value is 31st August 2016, calling setMonth with a value of 1 will return 2nd March 2016. This is because in 2016 February had 29 days.</p></blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth" target="_blank" rel="noopener">查看MDN解释</a></p><p>简单来说就是：对当前的日期调用setMonth操作时，如果当前月份的天数大于新的月份天数，那么日期会依次向后推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let now = new Date(new Date(&quot;2017-03-31&quot;).setMonth(new Date(&quot;2017-03-31&quot;).getMonth() + 1))</span><br><span class="line">console.log(&apos;now :&apos;, now.toLocaleString())</span><br><span class="line">// now : 2017/5/1 上午8:00:00</span><br><span class="line">// 2017-03-31 该月份有31天，当调用getMonth() + 1时</span><br><span class="line">// 理论上会加上当前月份的最大值31</span><br><span class="line">// 这时计算之后的日期是2017-04-31</span><br><span class="line">// 但是4月只有30天，所以后推一天变成2017-05-01,所以月份变成了5月</span><br></pre></td></tr></table></figure></p><ol start="2"><li>解决方法</li></ol><ul><li>setMonth之前先setDate(1)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getNextMonth(date) &#123;</span><br><span class="line">    const now = new Date(date);</span><br><span class="line">    now.setDate(1);</span><br><span class="line">    now.setMonth(now.getMonth() + 1);</span><br><span class="line">    return now.getMonth() + 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getNextMonth(&quot;2017-03-31&quot;))</span><br><span class="line">// 4  结果正确</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;问题重现&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
  </entry>
  
</feed>
